//포인터 자료형
//컴퓨터에서의 의미 메모리의 주소
//한 바이트마다 고유한 주소 존재.

//일반 변수 및 배열 = 값을 처리하기 위한 자료구조 -> a = 1000 값
//포인터 변수 = 메모리 어딘가를 가리키기 위한 자료구조 -> *a = 1000 주소 메모리 1000번지

// * 아스트리크
자료형* 변수명;
int* a;

char* cp; //cp는 주소가 저장될 변수 자료형은 문자(char)
//포인터 변수 선언은 주소를 담을 공간을 할당 받는 것. 주소에 대한 저장이 이루어지지 않음. cp가 메모리를 가르키지 않는 상태 아직 사용할 수 없음

//뒤에 따라오는 변수의 주소를 의미하는 & 연산자 엔퍼센트
cp=&ch;  //할당 받은 메모리 주소를 cp 포인터 변수에 대입 연산자를 이용하여 저장.
// &사용하지 않으면 메모리 관련 에러 발생
//scanf 표준 입력 장치로부터 입력된 값을 메모리 주소에 저장하는 역할

char* ch;
cp=&ch;

//포인터 변수 앞에 쓰이는 * 아스트리크 연산자 포인터 변수가 가리키는 곳의 내용(값)을 의미
*cp = 'A';
ch = 'A';

//포인터 증감 연산자의 사용
*p++; // 포인터 변수 p는 다음 번지 주소로 변경된 후 메모리 내용 참조.
(*p)++; // 포인터 변수가 가리키는 곳의 내용 증가.

char str[6], *ptr;
ptr=str; // ptr = &str[0];


#include<stdio.h>

int main()
{
  int num[5] = {10,20,30,40,50};
  int* p,i;

  p=num; //p포인터 변수에 num 배열의 시작 주소 대입
  for (i = 0; i < 5; i++) {
    printf("num[%d]:%d\n", i,num[i]);
  }
  for (i = 0; i < 5; i++) {
    printf("*(p+%d):%d\n",i,*(p+i));
  }
}


// 자유롭게 메모리로 접근하기 위해 포인터를 사용
// 메모리 할당이 우선
// 메모리 할당 방법 변수 및 배열 선언
// 프로그램 실행 시 미리 고정된 크기의 메모리가 할당된 상태
// 데이터 개수가 유동적일 경우 불필요한 공간을 크게 확보하거나 일정 개수 이상 관리 불가 문제 발생.

// 동적 메모리 할당 방법을 이용해 극복 가능
// 동적 할당 함수를 사용

void* malloc(size_t size);
// 사이즈에 명시된 크기만큼 메모리를 할당 받는 함수
// 사이즈는 메모리 할당 크기(바이트 수 기준)

void* calloc(size_t nmemb, size_t size);
// nmemb*size 크기만큼 메모리를 할당 받는 함수
// nmemb : 자료형의 크기, size: 개수
// 할당 받은 메모리를 모두 0으로 초기화까지 해주는 함수

void* realloc(void* ptr, size_t size);
// 이미 동적 할당을 받아 사용 중인 공간을 다시 재할당 받아야 할 때 사용
// ptr : 기존에 사용하던 메모리의 시작 주소, size : 재할당을 받을 메모리 크기

// 세 함수 모두 포인터 변수로 받아옴.

void* // 함수 원형에 제공된 리턴 타입, 반환 값 포인터 변수에 대입하여 사용

//동적 메모리 : 힙 세그먼트에 별도로 공간 할당 받음. free 함수로 해제하지 않는 한 계속 메모리 점유한다.
// 주소만 알아도 다른 함수에서도 동적 할당된 메모리 공간을 함께 사용 가능.
// 운영체제에서 메모리의 빈 공간을 확보하지 못한다면? NULL반환 때문에 널값인지 항상 체크해줘야함.

void free(void *ptr);
// ptr 포인터 변수가 가리키는 메모리를 해제하는 함수.
// 반드시 동적 할당 받은 메모리의 시작 주소를 넘겨줘야 함. 시작 주소가 아닌 주소를 인자로 전달 시 함수 수행 시 오류 발생.
// 반드시 동적 할당 받은 메모리는 이 함수로 해제해야 함. 해제 안하면 메모리 고갈 가능성 있음 (메모리 누수 현상!!!)

#include<stdlib.h> // 함수의 원형이 선언되어 있음 (동적할당 할 때 선언 해야됨! )
