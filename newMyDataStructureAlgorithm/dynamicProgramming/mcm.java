Matrix Chain Multiplication

행렬의 곱셈에 대해 생각해봅시다.
N*M행렬 A와 M*K행렬 B가 있을 때, A * B의 결과 행렬 C의 크기는 N*K이며, C를 구하기 위해서는 N*M*K번의 곱셈이 수행됩니다.
이러한 성질 때문에 여러 행렬을 곱할 때, 어떠한 행렬쌍을 먼저 곱하는지에 따라서 전체의 곱셈 연산 횟수가 달라지게 됩니다.
Matrix Chain Multiplication은 이러한 곱셈 연산의 횟수를 최소로 하는 문제입니다.

A : 2*3 행렬, B : 3*5 행렬, C : 5*2 행렬

위와 같은 세 개의 행렬에 대해, A*B*C를 계산해야 한다고 생각해봅시다.
A*B*C를 연산하는 방법에는 아래와 같이 두 가지 경우가 있으며, 연산 순서에 따라 전체 연산 횟수가 달라짐을 알 수 있습니다.

1. (A*B)*C
위 순서로 계산하는 경우 곱셈 연산의 횟수는 (2*3*5) + (2*5*2)로, 총 50번의 곱셈이 수행됩니다.
2. A*(B*C)
위 순서로 계산하는 경우 곱셈 연산의 횟수는 (3*5*2) + (2*3*2)로, 총 42번의 곱셈이 수행됩니다.
여러 개의 행렬을 곱해야 할 때 최소 곱셈 횟수를 구하는 문제에 대해서 생각해봅시다.
이 문제를 해결하기 위해서는 아래와 같은 테이블을 정의할 수 있습니다.

D[i][j] : i~j번까지의 행렬을 모두 곱하는데 드는 최소 곱셈횟수 (항상 i <= j를 만족한다.)
matrix[i][0] : i번째 행렬의 행의 수, matrix[i][1] : i번째 행렬의 열의 수

연속된 작은 구간들부터 연산해봅시다.
[i, j] 구간의 연속된 L개 행렬의 곱셈 연산을 생각해봅시다.
해당 구간의 L개 행렬 연산은 아래와 같이 나눠볼 수 있습니다.

1. [i, i]의 결과 행렬 * [i + 1, j]의 결과 행렬
2.	[i, i + 1]의 결과 행렬 * [i + 2, j]의 결과 행렬
L-1. [i, j - 1]의 결과 행렬 * [j, j]의 결과 행렬
즉 [i, j]구간은 2개의 구간 [i, k], [k+1, j]로 나누어 2개의 결과 행렬을 곱하는 과정을 통해 구해질 수 있습니다.
이때 L개의 연속된 구간의 곱할 때 연산 횟수를 구하기 위해서는 위의 L-1가지 경우에서 쓰일 1 ~ L-1개의 연속된 구간의 곱할 때 최소 연산 횟수들이 필요합니다.
또한 [i, k]의 구간의 결과 행렬은 Ri * Ck의 크기를 가지며, [k+1, j] 구간의 결과 행렬은 Rk+1 * Cj의 크기를 가집니다.
따라서 두 구간의 연산 결과는 두 구간을 구하는데 필요했던 연산 횟수 + (Ri * Ck * Cj)가 됩니다.
이러한 특성을 정리하면 아래와 같은 점화식을 얻을 수 있습니다.

D[i][j]=0	(if i == j)
D[i][j] = Mink = i to j-1(D[i][k] + D[k+1][j] + (Ri * Ck * Cj)) if(i != j)

이때, 위에서 언급했듯 D[i][j]는 항상 구간 길이가 L보다 작은 구간만 참조하게 되므로, 구간의 길이가 짧은 테이블부터 채워 나가게 되면 D[0][N-1]에 전체 행렬을 곱하는데 필요한 최소 연산 횟수가 구해지게 됩니다.

아래는 곱해야 하는 행렬이 순서대로 주어졌을 때, 결과 행렬을 구하기 위해 필요한 최소 곱셈 횟수를 동적 계획법으로 구현한 코드입니다.

import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        int r[] = new int[n];
        int c[] = new int[n];
        for (int i = 0; i < n; i++) {
            r[i] = sc.nextInt();
            c[i] = sc.nextInt();
        }

        int d[][] = new int[n][n];
        for (int l = 1; l < n; l++) {
            for (int i = 0; i < n - l; i++) {
                int j = i + l;
                d[i][j] = -1;
                for (int k = i; k < j; k++) {
                    int calc = d[i][k] + d[k + 1][j] + r[i] * c[k] * c[j];
                    if (d[i][j] < 0) {
                        d[i][j] = calc;
                    }
                    else if (calc < d[i][j]) {
                        d[i][j] = calc;
                    }
                }
            }
        }
        System.out.println(d[0][n - 1]);
    }
}
